#pragma once
/* Copyright (C) Ralf Kubis */

#include "r_base/language_tools.h"
#include "r_base/Log.h"
#include "r_base/expected.h"

#include <memory>
#include <exception>
#include <string>


namespace nsBase
{
class Error
:   public ::std::exception
{
    R_DTOR(Error) = default;
    R_CTOR(Error) = delete;

    // This is a Hack to enable throwing via ::tl::bad_expected_access;
    // The implementation of ::tl::ecpected::value() throws a copy of the error object.
    R_CCPY(Error)
        {
            m_log = ::std::move(src.m_log);
            src.m_log.do_broadcast_assign(false);
            src.m_log.broadcast_if_and_clear();
        }

    R_CMOV(Error)
        {
            operator=(::std::move(src));
        }

    R_COPY(Error) = delete;
    R_MOVE(Error)
        {
            m_log  = ::std::move(src.m_log);
            return *this;
        }

    public : Error(Log && l)
        :   m_log(::std::move(l))
        {
            m_log.level_raise_to(Log::Level::FAILURE);
        }

    // required to write:
    //   throw Error(Log(..).message(..))
    // instead of
    //   throw Error(::std::move(Log(..).message(..)))
    public : Error(Log & l)
        :   Error(::std::move(l))
        {
        }

    public : virtual const char *
        what() const noexcept override
            {
                using namespace ::std::string_literals;

                try
                {
                    what_cache = u8"b25bdc13-2348-417a-bbae-9147b34539ed"s;
                    what_cache = log().message_resolved();
                }
                catch(...)
                {}

                return what_cache.c_str();
            }

    private : mutable ::std::string
        what_cache;

    private : mutable Log
        m_log;

    public : Log const &
        log() const
            {
                return m_log;
            }

    public : Log &
        log_mutable()
            {
                return m_log;
            }
};


/** Get an Error object that reflects the given exception object.
    If e is of class Error or ::tl::bad_expected_access<Error>, the Log is obtained from e.
    Otherwise a new Log is created with the value of ::std::exception::what()
    stored in its 'message' attribute.
    In any case, the value of parameter 'trace_id' is added to the Logs trace
    to make the routing of the event reproducible.
*/
inline Error
to_Error(
    ::std::exception & e
,   ::uuids::uuid      trace_id
)
{
    // in case e is ::nsBase::Error
    if (auto err = dynamic_cast<Error*>(&e))
        return {::std::move(err->log_mutable().trace(trace_id))};

    // in case e is ::tl::bad_expected_access<::nsBase::Error>
    if (auto err = dynamic_cast<::tl::bad_expected_access<Error>*>(&e))
        return {::std::move(err->error().log_mutable().trace(trace_id))};

    return {Log(trace_id).message(e.what()).trace(trace_id)};
}


template<class Expected>
void
throw_on_error(
    Expected         & exp
,   ::uuids::uuid      trace_id
)
{
    if (!exp)
        throw to_Error(exp.error(), trace_id);
}

}
